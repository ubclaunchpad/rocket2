"""Represent a team project."""
from typing import List, Dict, Any, TypeVar, Type
import uuid
from app.model.base import RocketModel

T = TypeVar('T', bound='Project')


class Project(RocketModel):
    """Represent a team project with team ID and related fields and methods."""

    def __init__(self,
                 github_team_id: str,
                 github_urls: List[str]):
        """
        Initialize the team project.

        Project ID is a UUID generated by ``uuid.uuid4()``.

        :param github_team_id: the Github team ID associated with the project
        :param github_urls: a set/list of URLs pointing to repositories
        """
        self.project_id = str(uuid.uuid4())
        self.github_team_id = github_team_id
        self.github_urls = github_urls

        self.displayname = ''
        self.short_description = ''
        self.long_description = ''
        self.tags: List[str] = []
        self.website_url = ''
        self.medium_url = ''
        self.appstore_url = ''
        self.playstore_url = ''

    def get_attachment(self) -> Dict[str, Any]:
        """Return slack-formatted attachment (dictionary) for project."""
        text_pairs = [
            ('Project ID', self.project_id),
            ('Github Team ID', self.github_team_id),
            ('GitHub URLs', '\n'.join(self.github_urls)),
            ('Display Name', self.displayname),
            ('Short Description', self.short_description),
            ('Long Description', self.long_description),
            ('Tags', '\n'.join(self.tags)),
            ('Website URL', self.website_url),
            ('Medium URL', self.medium_url),
            ('App Store URL', self.appstore_url),
            ('Play Store URL', self.playstore_url)
        ]

        fields = [{'title': t, 'value': v if v else 'n/a', 'short': True}
                  for t, v in text_pairs]
        fallback = str('\n'.join(map(str, text_pairs)))

        return {'fallback': fallback, 'fields': fields}

    @classmethod
    def from_dict(cls: Type[T], d: Dict[str, Any]) -> T:
        """
        Return a project from a dict object.

        :param d: the dictionary (usually from DynamoDB)
        :return: a Project object
        """
        p = cls(d['github_team_id'], d['github_urls'])
        p.project_id = d['project_id']
        p.displayname = d.get('displayname', '')
        p.short_description = d.get('short_description', '')
        p.long_description = d.get('long_description', '')
        p.tags = d.get('tags', [])
        p.website_url = d.get('website_url', '')
        p.medium_url = d.get('medium_url', '')
        p.appstore_url = d.get('appstore_url', '')
        p.playstore_url = d.get('playstore_url', '')

        return p

    @classmethod
    def to_dict(cls: Type[T], p: T) -> Dict[str, Any]:
        """
        Return a dict object representing a project.

        The difference with the in-built ``self.__dict__`` is that this is more
        compatible with storing into NoSQL databases like DynamoDB.

        :param p: the Project object
        :return: a dictionary representing a project
        """
        def place_if_filled(name: str, field: Any):
            """Populate ``udict`` if ``field`` isn't empty."""
            if field:
                udict[name] = field

        udict = {
            'project_id': p.project_id,
            'github_urls': p.github_urls
        }
        place_if_filled('github_team_id', p.github_team_id)
        place_if_filled('displayname', p.displayname)
        place_if_filled('short_description', p.short_description)
        place_if_filled('long_description', p.long_description)
        place_if_filled('tags', p.tags)
        place_if_filled('website_url', p.website_url)
        place_if_filled('appstore_url', p.appstore_url)
        place_if_filled('playstore_url', p.playstore_url)

        return udict

    @classmethod
    def is_valid(cls: Type[T], p: T) -> bool:
        """
        Return true if this project has no missing fields.

        Required fields for database to accept:
            - ``__project_id``
            - ``__github_urls``

        :param project: project to check
        :return: true if this project has no missing fields
        """
        return len(p.project_id) > 0 and\
            len(p.github_urls) > 0

    def __eq__(self, other: object) -> bool:
        """Return true if this project is equal to the other project."""
        return isinstance(other, Project) and str(self) == str(other)

    def __ne__(self, other: object) -> bool:
        """Return true if this project isn't equal to the other project."""
        return not (self == other)

    def __str__(self) -> str:
        """Return all fields of this project, JSON format."""
        return str(self.__dict__)

    def __hash__(self) -> int:
        """Hash the project class using a dictionary."""
        return self.__str__().__hash__()
